Общие рекомендации:
1. Разделить сервис на более мелкие с четкой ответственностью

Выявленные проблемы:
1. Ошибка при вызове ProductRegistry.getMyCatalogVersion (неправильный аргумент from_)
2. Отсутствует метод getAllProducts в ABI контракта
3. Нет проверки реальных данных в каталоге


2. Внедрить единый механизм кэширования
3. Использовать асинхронные операции где возможно
4. Структурировать логирование
5. Добавить слой безопасности
6. Использовать типизацию и валидацию данных
7. Внедрить обработку ошибок на всех уровнях
8. Добавить мониторинг производительности

План тестирования ProductRegistry
===============================

Анализ текущего покрытия:
------------------------
✅ Протестировано:
- Инициализация ProductRegistryService
- Базовое подключение к смарт-контрактам (InviteNFT, ProductRegistry)
- Проверка версии каталога (getMyCatalogVersion)
- Базовая проверка получения списка продуктов

❌ Требует тестирования:
1. Управление продуктами
   - Создание продукта
     * Валидация входных данных
     * Загрузка изображений в IPFS
     * Создание метаданных
     * Вызов смарт-контракта
     * Проверка результата
   
   - Обновление продукта
     * Валидация изменений
     * Обновление метаданных
     * Вызов смарт-контракта
     * Проверка обновленных данных
   
   - Деактивация продукта
     * Проверка прав доступа
     * Вызов смарт-контракта
     * Подтверждение деактивации

2. Работа с метаданными
   - Создание метаданных
     * Валидация обязательных полей
     * Форматирование данных
     * Загрузка в IPFS
   
   - Обновление метаданных
     * Частичное обновление
     * Полное обновление
     * Валидация изменений

3. Работа с IPFS/Arweave
   - Загрузка файлов
     * Проверка размера
     * Валидация формата
     * Получение CID
   
   - Получение файлов
     * Проверка доступности
     * Кэширование
     * Обработка ошибок

4. Кэширование
   - Кэширование метаданных
     * Сохранение в кэш
     * Получение из кэша
     * Инвалидация кэша
   
   - Кэширование изображений
     * Сохранение превью
     * Получение из кэша
     * Управление TTL

5. Валидация
   - Проверка прав доступа
     * Роли пользователей
     * Права на операции
     * Ограничения
   
   - Валидация данных
     * Обязательные поля
     * Форматы данных
     * Бизнес-правила

План юнит-тестирования:
----------------------
1. ProductMetadataService
   - createMetadata
   - validateMetadata
   - updateMetadata
   - getMetadata

2. ProductCacheService
   - cacheProduct
   - getCachedProduct
   - invalidateCache
   - getCacheStats

3. ProductStorageService
   - uploadFile
   - getFile
   - validateCID
   - checkAvailability

4. ProductValidationService
   - validateProduct
   - validateSeller
   - validatePermissions
   - validateBusinessRules

5. ProductBlockchainService
   - createProduct
   - updateProduct
   - deactivateProduct
   - getProducts

План интеграционного тестирования:
--------------------------------
1. Сценарий создания продукта
   - Подготовка данных
   - Загрузка изображений
   - Создание метаданных
   - Сохранение в блокчейн
   - Проверка результата

2. Сценарий обновления продукта
   - Получение существующего продукта
   - Изменение данных
   - Обновление метаданных
   - Сохранение изменений
   - Проверка обновлений

3. Сценарий деактивации продукта
   - Поиск активного продукта
   - Деактивация
   - Проверка статуса
   - Попытка повторной деактивации

4. Сценарий получения каталога
   - Создание нескольких продуктов
   - Получение полного каталога
   - Фильтрация по продавцу
   - Проверка пагинации

5. Сценарий работы с кэшем
   - Создание продукта
   - Проверка кэширования
   - Инвалидация кэша
   - Обновление данных

Чек-лист для каждого теста:
--------------------------
1. Подготовка тестовых данных
   - Создание моков
   - Подготовка фикстур
   - Настройка окружения

2. Проверка успешного сценария
   - Валидные данные
   - Ожидаемый результат
   - Проверка состояния

3. Проверка граничных случаев
   - Пустые значения
   - Максимальные значения
   - Некорректные форматы

4. Проверка обработки ошибок
   - Сетевые ошибки
   - Ошибки валидации
   - Ошибки доступа

5. Очистка после теста
   - Удаление тестовых данных
   - Восстановление состояния
   - Очистка кэша

План рефакторинга системы сервисов
================================

### 1. Реорганизация BlockchainService
**Задача**: Трансформировать BlockchainService в синглтон с четким разделением ответственности
**Обоснование**: Необходимо обеспечить единую точку доступа к блокчейну и избежать множественной инициализации контрактов
**Шаги**:
- [ ] Реализовать паттерн синглтон
- [ ] Добавить фабричный метод getInstance()
- [ ] Обновить все зависимые сервисы для работы с синглтоном
- [ ] Вынести логику работы с аккаунтами в AccountService

### 2. Реструктуризация ProductRegistryService
**Задача**: Привести ProductRegistryService к принципам SOLID
**Обоснование**: Текущая реализация имеет слишком много ответственности и прямых зависимостей
**Шаги**:
- [ ] Переименовать в ProductRegistryService
- [ ] Внедрить зависимости через конструктор
- [ ] Удалить прямые импорты сервисов
- [ ] Добавить интерфейсы для всех зависимостей

### 3. Унификация Storage Providers
**Задача**: Создать единый интерфейс для всех провайдеров хранения
**Обоснование**: Необходимо обеспечить взаимозаменяемость провайдеров и упростить тестирование
**Шаги**:
- [ ] Создать IStorageProvider интерфейс
- [ ] Реализовать интерфейс в PinataProvider
- [ ] Реализовать интерфейс в AsyncPinataProvider
- [ ] Интегрировать с IPFSFactory

### 4. Улучшение ProductStorageService
**Задача**: Абстрагировать работу с хранилищем через IPFSFactory
**Обоснование**: Необходимо унифицировать работу с разными провайдерами хранения
**Шаги**:
- [ ] Интегрировать IPFSFactory
- [ ] Добавить абстракцию провайдеров
- [ ] Реализовать стратегию выбора провайдера
- [ ] Добавить обработку ошибок специфичных для провайдеров

### 5. Обновление тестовой инфраструктуры
**Задача**: Адаптировать тесты под новую архитектуру
**Обоснование**: Необходимо обеспечить надежное тестирование новой структуры сервисов
**Шаги**:
- [ ] Создать фикстуры для всех сервисов
- [ ] Добавить моки для внешних зависимостей
- [ ] Реализовать reset() для синглтонов
- [ ] Обновить conftest.py

### 6. Создание ServiceFactory
**Задача**: Реализовать централизованную фабрику сервисов
**Обоснование**: Необходимо обеспечить правильный порядок инициализации и переиспользование сервисов
**Шаги**:
- [ ] Создать синглтон ServiceFactory
- [ ] Реализовать инициализацию core сервисов
- [ ] Добавить создание product сервисов
- [ ] Обеспечить reset для тестов

### 7. Документация изменений
**Задача**: Задокументировать новую архитектуру и изменения
**Обоснование**: Необходимо обеспечить понимание новой структуры и облегчить поддержку
**Шаги**:
- [ ] Описать новую архитектуру
- [ ] Добавить диаграммы взаимодействия
- [ ] Обновить README
- [ ] Добавить примеры использования

Приоритеты выполнения:
1. BlockchainService (критично для всех остальных изменений)
2. ServiceFactory (необходимо для правильной инициализации)
3. Storage Providers (блокирует работу с ProductStorageService)
4. ProductRegistryService (зависит от предыдущих изменений)
5. Тестовая инфраструктура (должна развиваться параллельно)
6. Документация (финальный этап)

Критерии приемки для каждой Story:
--------------------------------
1. Код проходит все тесты
2. Покрытие тестами не менее 80%
3. Документация обновлена
4. Производительность не ухудшилась
5. Логирование структурировано
6. Обработка ошибок реализована
7. Code review пройден

## GAP-анализ и план унификации тестовой инфраструктуры ProductRegistryService

### 1. GAP-анализ: различия между тестами ProductRegistryService и AccountService

**1.1. Инфраструктура и окружение**
- В test_account_service.py:
  - Используются фикстуры pytest_asyncio для асинхронных сервисов
  - Явная загрузка .env и assert на наличие ключей
  - Логирование через StreamHandler и DEBUG-уровень
  - Проверка и подготовка аккаунтов (SELLER, USER) через фикстуры
  - Проверка ролей и прав доступа до теста
  - Использование reset() для синглтонов
- В test_product_registry.py:
  - Много ручной инициализации сервисов, часть фикстур синхронные
  - Не всегда проверяется наличие переменных окружения
  - Могут использоваться устаревшие/удалённые сервисы
  - Нет единого подхода к мокам и очистке состояния

**1.2. Стиль и структура тестов**
- В AccountService:
  - Каждый тест — отдельный метод класса
  - Четкая структура: подготовка, действие, проверка
  - Проверка граничных случаев и ошибок
  - Использование monkeypatch для проверки поведения при отсутствии env
- В ProductRegistryService:
  - Много интеграционных сценариев в одном тесте
  - Нет строгого разделения на юнит/интеграционные тесты
  - Могут тестироваться несуществующие методы
  - Не всегда есть очистка после теста

**1.3. Работа с асинхронностью**
- В AccountService — строго через pytest.mark.asyncio и async фикстуры
- В ProductRegistryService — смешение sync/async, часть сервисов не await

**1.4. Работа с моками и внешними сервисами**
- В AccountService — явные моки и patch для внешних вызовов
- В ProductRegistryService — часто реальные вызовы, мало моков

### 2. План унификации и исправления

1. **Фикстуры и окружение**
   - Все сервисы и зависимости должны инициализироваться через async фикстуры
   - Явная загрузка .env и assert на ключевые переменные (SELLER_PRIVATE_KEY и др.)
   - Использовать reset() для синглтонов перед каждым тестом
   - Проверять права и роли до теста, скипать если не назначены

2. **Стиль и структура тестов**
   - Каждый тест — отдельная функция/метод, четкая структура AAA (Arrange-Act-Assert)
   - Разделить юнит и интеграционные тесты
   - Не создавать тесты к несуществующим методам
   - Добавить очистку состояния/кэша после теста

3. **Асинхронность**
   - Все тесты, работающие с async сервисами — только через pytest.mark.asyncio
   - Все сервисы должны поддерживать async вызовы (или быть обернуты в async)

4. **Моки и внешние сервисы**
   - Использовать unittest.mock/patch для изоляции от внешних сервисов (IPFS, Blockchain, Arweave)
   - Для интеграционных тестов — отдельные сценарии с реальными сервисами

5. **Логирование и диагностика**
   - Единый стиль логирования (StreamHandler, DEBUG)
   - Явный вывод ключевых шагов теста

6. **Документация и чек-листы**
   - Для каждого теста — краткое описание, что проверяет
   - Чек-лист: подготовка, успешный сценарий, граничные случаи, ошибки, очистка

### 3. Публичные методы ProductRegistryService (только существующие)

- __init__
- clear_cache
- get_catalog_version
- create_product_metadata
- upload_product_metadata (TODO)
- upload_media_file (TODO)
- create_product_on_chain
- get_all_products
- get_product
- get_product_by_id
- validate_product (async)
- create_product (async)
- update_product_status
- set_product_active

**NB:** Методы upload_product_metadata и upload_media_file — заглушки (TODO), не тестировать до реализации.

### 4. Следующие шаги
- Привести все тесты ProductRegistryService к единому стилю с AccountService
- Удалить/пометить тесты к несуществующим методам
- Ввести строгую структуру фикстур и моков
- Обеспечить reset и очистку состояния между тестами
- Добавить подробное логирование и диагностику
- Проверить покрытие тестами всех публичных методов

## Конкретный план работы по унификации и рефакторингу ProductRegistryService и работы с метаданными

### 1. Аудит и выравнивание структуры данных
- [ ] Провести аудит структуры Product (product.py) и того, что реально возвращается из metadata.py
- [ ] Согласовать структуру Product с тем, что приходит из метаданных (пример: amanita1.json)
- [ ] Убрать жёстко заданные значения (например, arweave.net) из metadata-сервиса

### 2. Доработка Product класса и ProductMetadataService для соответствия структуре метаданных

#### 2.1. Анализ текущих несоответствий

**Структура метаданных (amanita1.json):**
```json
{
  "id": "amanita1",
  "title": "Amanita muscaria — sliced caps and gills (1st grade)",
  "description_cid": "QmdoqBWBZoupjQWFfBxMJD5N9dJSFTyjVEV1AVL8oNEVSG",
  "categories": ["mushroom", "mental health", "focus", "ADHD support", "mental force"],
  "cover_image": "QmYrs5gAMeZEmiFAJnmRcD19rpCpXF52ssMJ6X2oWrxWWj",
  "form": "mixed slices",
  "species": "Amanita muscaria",
  "prices": [...]
}
```

**description_cid указывает на структуру из organic_descriptions.json:**
```json
{
  "id": "amanita-muscaria",
  "title": "Мухомор красный",
  "scientific_name": "Amanita muscaria",
  "generic_description": "...",
  "effects": "...",
  "shamanic": "...",
  "warnings": "...",
  "dosage_instructions": [...]
}
```

#### 2.2. План доработки Product класса

**Шаг 1: Изменение конструктора Product**
- [ ] Заменить `cover_image_url: str` на `cover_image_cid: str`
- [ ] Заменить `forms: List[str]` на `form: str`
- [ ] Сделать `description: Description` опциональным (`Optional[Description] = None`)
- [ ] Добавить `status: int = 1` и `cid: str = ""` с значениями по умолчанию
- [ ] Обновить валидацию полей

**Шаг 2: Добавление методов для работы с CID**
- [ ] Добавить метод `get_description(storage_service)` для загрузки Description по description_cid
- [ ] Добавить метод `get_cover_image_url(storage_service)` для получения URL по cover_image_cid
- [ ] Добавить кэширование результатов в ProductCacheService
- [ ] Добавить обработку ошибок при загрузке данных

**Шаг 3: Обновление методов сериализации**
- [ ] Обновить `to_json()` для соответствия формату amanita1.json
- [ ] Обновить `from_json()` для поддержки обоих форматов (метаданные и полный объект)
- [ ] Добавить метод `from_metadata(metadata: Dict, cid: str = "", status: int = 1)` для создания из метаданных

**Шаг 4: Обратная совместимость**
- [ ] Сохранить старые методы для совместимости
- [ ] Добавить автоматическое преобразование между форматами
- [ ] Обновить существующие тесты

#### 2.3. План доработки ProductMetadataService

**Шаг 1: Устранение хардкода**
- [ ] Убрать хардкод `ar://` и `https://arweave.net/` из всех методов
- [ ] Использовать IPFSFactory для получения URL по CID
- [ ] Добавить поддержку разных провайдеров хранилищ

**Шаг 2: Добавление методов для работы с description_cid**
- [ ] Добавить метод `load_description_by_cid(description_cid: str)` для загрузки структурированного описания
- [ ] Добавить метод `create_description_from_cid(description_cid: str)` для создания объекта Description
- [ ] Интегрировать с ProductCacheService для кэширования
- [ ] Добавить обработку ошибок и fallback значения

**Шаг 3: Обновление process_metadata**
- [ ] Изменить логику для работы с новой структурой Product
- [ ] Добавить загрузку Description по description_cid
- [ ] Использовать cover_image_cid вместо cover_image_url
- [ ] Обрабатывать form как строку
- [ ] Добавить валидацию обязательных полей

**Шаг 4: Интеграция с кэшем**
- [ ] Использовать ProductCacheService для кэширования описаний
- [ ] Добавить TTL для разных типов данных
- [ ] Реализовать инвалидацию кэша при обновлении данных

#### 2.4. План обновления ProductRegistryService

**Шаг 1: Обновление _process_product_metadata**
- [ ] Изменить создание Product для использования новой структуры
- [ ] Добавить загрузку Description по description_cid
- [ ] Использовать cover_image_cid и получение URL через фабрику
- [ ] Обрабатывать form как строку

**Шаг 2: Обновление методов работы с продуктами**
- [ ] Обновить `get_product()` для работы с новой структурой
- [ ] Обновить `get_all_products()` для корректной обработки метаданных
- [ ] Добавить методы для декодирования данных по CID

**Шаг 3: Интеграция с кэшем**
- [ ] Использовать кэширование для описаний и изображений
- [ ] Добавить методы для управления кэшем
- [ ] Реализовать автоматическое обновление кэша

#### 2.5. План тестирования

**Шаг 1: Обновление существующих тестов**
- [ ] Обновить тесты для работы с новой структурой Product
- [ ] Добавить тесты для методов загрузки по CID
- [ ] Протестировать кэширование

**Шаг 2: Создание новых тестов**
- [ ] Тесты для `from_metadata()` метода
- [ ] Тесты для загрузки Description по CID
- [ ] Тесты для работы с cover_image_cid
- [ ] Тесты кэширования

**Шаг 3: Интеграционные тесты**
- [ ] Тесты с реальными метаданными amanita1.json
- [ ] Тесты с реальными данными из organic_descriptions.json
- [ ] Тесты полного цикла: метаданные → Product → кэш → декодирование

#### 2.6. Ожидаемые результаты

После доработки:
- ✅ Product корректно создается из метаданных amanita1.json
- ✅ description_cid правильно декодируется в объект Description
- ✅ cover_image_cid преобразуется в URL через IPFSFactory
- ✅ form обрабатывается как строка
- ✅ Кэширование работает для всех типов данных
- ✅ Убран хардкод URL'ов
- ✅ Обратная совместимость сохранена

#### 2.7. Приоритеты выполнения

1. **Критично**: Изменение конструктора Product и добавление методов для работы с CID
2. **Важно**: Обновление ProductMetadataService и устранение хардкода
3. **Средне**: Интеграция с кэшем и обновление ProductRegistryService
4. **Низко**: Тестирование и документация

