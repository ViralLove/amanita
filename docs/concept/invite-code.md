# Использование параметра start (deep-link) для инвайт-кода в Telegram-боте

## Техническая рекомендация

Telegram официально поддерживает передачу параметра ?start=INVITE_CODE при первом запуске бота по deep-link. Это позволяет автоматически подставлять инвайт-код в онбординге и не требовать ручного ввода, если пользователь перешёл по специальной ссылке.

**Как это реализовано у нас:**
- При первом запуске бота по ссылке вида `https://t.me/our_bot?start=INVITE_CODE` бот автоматически извлекает INVITE_CODE из message.text (`/start INVITE_CODE`).
- Если код найден, он сразу подставляется в онбординг, пользователь видит подтверждение и может продолжить без ручного ввода.
- Если кода нет — бот предлагает ввести инвайт вручную.
- Вся логика проверки и валидации кода реализована на сервере, чтобы избежать подделки или повторного использования.

## Ограничения и кейсы, когда deep-link не сработает

1. **Повторный запуск бота**
   - Если пользователь уже запускал бота ранее, Telegram не передаёт параметр ?start=... повторно.
   - В этом случае бот не сможет автоматически подставить инвайт-код.

2. **Ручной поиск бота**
   - Если пользователь ищет бота в Telegram и нажимает "Start" без перехода по ссылке, параметр отсутствует.

3. **Пользователь заблокировал бота ранее**
   - Если бот был заблокирован, событие не поступит, даже если параметр есть в ссылке.

4. **Web-версия Telegram без авторизации**
   - После логина параметр может сохраниться, но возможны сбои при редиректе.

5. **Параметр не является доказательством личности**
   - INVITE_CODE — это открытый токен, не шифруется, может быть скопирован или переслан. Всегда требуется серверная валидация.

## UX-решения для всех кейсов

- **Если код найден:**
  - Показываем пользователю, что код обнаружен, и предлагаем подтвердить его одним нажатием.
- **Если кода нет:**
  - Просим ввести инвайт-код вручную, объясняем почему это нужно.
- **Если код некорректен или уже использован:**
  - Показываем ошибку и предлагаем повторить ввод или обратиться за новым кодом.
- **Если пользователь стартует повторно:**
  - Не путаем пользователя — сразу предлагаем ввести код вручную, если deep-link не сработал.

## Резюме

Использование deep-link с параметром ?start=INVITE_CODE — это удобный и быстрый способ онбординга, но он работает только при первом запуске бота по ссылке. Всегда реализуйте fallback на ручной ввод и информируйте пользователя о причине, чтобы UX оставался простым и понятным в любом сценарии.

# Доработки на уровне контракта

Задача для метода services.blockchain.validate_invite_code:
Входные параметры:
invite_code (str): инвайт-код, введённый или полученный пользователем
user_id (int/str): Telegram user_id пользователя
Функционал:
Проверить, существует ли такой инвайт-код в контракте/БД
Проверить, не был ли он уже использован
Проверить, не истёк ли срок действия кода (если применимо)
Проверить, принадлежит ли код валидному участнику
Вернуть результат: валиден/не валиден + причина (например: "уже использован", "не найден", "истёк срок", "не принадлежит участнику")
Выход:
success (bool)
reason (str) — если не валиден
Ошибки:
Все ошибки должны логироваться и возвращаться в виде понятного сообщения для пользователя

# Web3 Invite Архитектура

## Адаптированное решение для AMANITA на базе Invite NFT

### 1. Хранение и идентификация инвайтов
- Каждый инвайт — это отдельный NFT (Invite NFT), у которого есть уникальный tokenId (uint256).
- Владелец инвайта — это адрес, на который заминчен NFT.
- Для проверки и активации инвайта используется tokenId, а не строковый inviteCode.
- Если нужен inviteCode для UX (например, короткий код для передачи), реализуется off-chain маппинг inviteCode → tokenId (например, в базе бота или через отдельный mapping в контракте).

### 2. Генерация и выдача инвайтов
- Инвайты создаются через mint (обычно с ролью FACTORY_ROLE или админом).
- При минтинге NFT назначается владельцу (owner).
- Владелец может передать инвайт другому пользователю (если это разрешено правилами).

### 3. Проверка валидности инвайта (валидация)
- Для проверки валидности инвайта используется функция вида:

```solidity
function validateInviteToken(uint256 tokenId, address user) public view returns (bool, string memory) {
    if (!_exists(tokenId)) {
        return (false, "not_found");
    }
    if (ownerOf(tokenId) != user) {
        return (false, "not_owner");
    }
    if (isInviteUsed[tokenId]) {
        return (false, "already_used");
    }
    if (usedInviteByUser[user] != 0) {
        return (false, "user_already_used");
    }
    return (true, "");
}
```
- Проверки:
  - Существует ли такой инвайт (tokenId)
  - Является ли пользователь владельцем этого инвайта
  - Не был ли инвайт уже использован
  - Не использовал ли пользователь другой инвайт

### 4. Активация инвайта
- После успешной валидации вызывается функция активации:

```solidity
function setInviteUsed(uint256 tokenId, address user) external onlyRole(FACTORY_ROLE) {
    require(_exists(tokenId), "Token does not exist");
    require(ownerOf(tokenId) == user, "User is not the owner of this token");
    require(!isInviteUsed[tokenId], "Invite already used");
    isInviteUsed[tokenId] = true;
    usedInviteByUser[user] = tokenId;
    emit InviteUsed(tokenId, user, block.timestamp);
}
```
- Инвайт помечается как использованный, и за пользователем закрепляется этот tokenId.

### 5. Интеграция с Telegram-ботом
- Пользователь вводит или получает inviteCode/tokenId.
- Бот через web3.py вызывает `validateInviteToken(tokenId, user_address)`.
- Если результат успешный — бот вызывает `setInviteUsed(tokenId, user_address)` (через транзакцию).
- Если inviteCode — строка, бот сначала маппит его на tokenId (off-chain).
- Все статусы и ошибки возвращаются в UX пользователя.

### 6. UX и безопасность
- Пользователь всегда видит, почему инвайт не может быть использован (уже использован, не принадлежит, не найден и т.д.).
- Инвайт-код не является секретом, но должен быть уникальным и не угадываемым (если используется строковый inviteCode).
- Все проверки происходят на контракте, бот только отображает результат.
- Для передачи inviteCode можно использовать QR-код, ссылку или просто число (tokenId).

### 7. Рекомендации
- Использовать только tokenId для всех внутренних операций.
- Если нужен inviteCode для UX — поддерживать off-chain маппинг inviteCode → tokenId.
- Все критические проверки (владение, использование, уникальность) реализовать на контракте.
- Для интеграции с ботом использовать web3.py и методы validateInviteToken/setInviteUsed.

### 8. История передач инвайта (полный аудит)
- Для каждого инвайта (tokenId) ведётся массив всех владельцев (address[]), через mapping inviteTransferHistory.
- Позволяет полностью отследить путь инвайта: кто, когда и сколько раз его передавал.
- Важно для аудита, расследований, построения реферальных деревьев, анализа активности продавцов и участников.
- Может использоваться для бонусных программ, выявления подозрительных схем, прозрачности экосистемы.

---

**Это решение полностью повторяет проверенные паттерны из CapybaraInviteNFT и адаптировано под задачи AMANITA: максимальная прозрачность, безопасность, простота интеграции с Telegram-ботом и масштабируемость.**

# Хранение мап и списков в контракте для инвайтов

1. Маппинг inviteCode ↔ tokenId
inviteCodeToTokenId
Зачем: Позволяет быстро найти NFT-инвайт по коду, который пользователь вводит или получает (например, из ссылки или QR-кода). Это критично для UX: пользователь работает с коротким inviteCode, а контракт — с tokenId.
В боте: При вводе кода бот маппит inviteCode на tokenId и далее работает с ним.
tokenIdToInviteCode
Зачем: Для обратной связи — если нужно показать пользователю его inviteCode по tokenId (например, для передачи другому).
В боте/экосистеме: Удобно для отображения, аудита, поддержки.
Уникальность inviteCode
Зачем: Исключает дублирование и ошибки при активации инвайтов. Один inviteCode — один инвайт.
2. Статус использования инвайта
isInviteUsed
Зачем: Гарантирует, что инвайт может быть использован только один раз.
В боте: После успешной активации инвайта этот флаг обновляется, и повторное использование невозможно.
usedInviteByUser
Зачем: Не позволяет одному пользователю использовать несколько инвайтов (например, для обхода ограничений или повторной регистрации).
В боте/экосистеме: Защищает от мультиаккаунтинга, поддерживает честность системы.
Синхронное обновление обоих mapping
Зачем: Исключает рассинхронизацию статусов, предотвращает баги и мошенничество.
3. Владение и история
ownerOf(tokenId)
Зачем: Стандарт ERC721 — определяет, кто сейчас владеет инвайтом.
В боте: Проверка, что пользователь действительно может активировать этот инвайт.
inviteFirstOwner
Зачем: Для аудита, статистики, возможных бонусов за приглашения, отслеживания «родословной» инвайта.
В экосистеме: Позволяет строить реферальные деревья, анализировать рост сети.
inviteMinter
Зачем: Позволяет отслеживать, кто создал инвайт (например, продавец или админ).
В экосистеме: Важно для контроля эмиссии, распределения прав и бонусов.
userInvites
Зачем: Быстрый доступ ко всем инвайтам пользователя (например, для отображения в личном кабинете, управления инвайтами).
В боте/экосистеме: Удобно для массовых операций, статистики, поддержки.
4. Срок действия и дата создания
inviteExpiry
Зачем: Позволяет делать инвайты временными (например, для акций, ограниченного доступа).
В боте: Бот может объяснить пользователю, почему инвайт не работает (истёк срок).
inviteCreatedAt
Зачем: Для аудита, статистики, отслеживания «свежести» инвайтов.
В экосистеме: Можно анализировать динамику роста, выявлять неактивные инвайты.
Корректная инициализация при минтинге
Зачем: Исключает баги, связанные с невалидными или «вечными» инвайтами.
5. Учёт общего количества
totalInvitesMinted / totalInvitesUsed
Зачем: Для мониторинга, лимитов, аналитики, контроля эмиссии инвайтов.
В экосистеме: Позволяет видеть, сколько инвайтов реально используется, а сколько «висят мёртвым грузом».
6. Уникальность и безопасность
Уникальность inviteCode
Зачем: Исключает коллизии, защищает от случайных/злонамеренных дублей.
В боте/экосистеме: Гарантирует, что пользователь не сможет активировать чужой или несуществующий инвайт.
Ограничение на один инвайт на пользователя
Зачем: Защищает от мультиаккаунтинга, поддерживает честность и прозрачность.
В экосистеме: Важно для построения доверия и предотвращения злоупотреблений.
Ограничение на повторное использование инвайта
Зачем: Гарантирует, что каждый инвайт — это уникальный шанс для нового участника.
7. Расширяемость
Гибкая структура
Зачем: Позволяет легко добавлять новые параметры (например, тип инвайта, бонусы, метаданные) без ломки архитектуры.
В экосистеме: Важно для масштабирования, интеграции с маркетплейсом, аналитикой, новыми сценариями.
Доступность через view-функции
Зачем: Упрощает интеграцию с ботом, фронтом, аналитикой, сторонними сервисами.
В боте/экосистеме: Позволяет строить прозрачные и быстрые интерфейсы для пользователей и админов.
Резюме:
Каждый пункт чеклиста — это не просто техническая деталь, а фундамент для прозрачной, защищённой и масштабируемой экосистемы Amanita, где Telegram-бот — лишь один из интерфейсов, а архитектура инвайтов поддерживает рост, аналитику, честность и удобство для всех участников, включая продавцов, покупателей и админов.

# Стратегия анонимности и безопасности внутри экосистемы

1. Профиль пользователя = адрес
Ваша идея: профиль пользователя — это просто адрес (wallet), который получает инвайт и токены через одного из ботов-продавцов.
После первой активации инвайта этот адрес становится «участником» всей экосистемы Amanita, и может использоваться во всех ботах и сервисах.
Нет личных данных, только история on-chain — полная анонимность.
Плюсы:
Максимальная децентрализация и приватность.
Пользователь может использовать один и тот же адрес во всех сервисах и у разных продавцов.
Легко строить экосистему с множеством независимых ботов и продавцов.
2. Можно ли разрешать подключать любой адрес?
Вариант 1: Разрешать только адреса, созданные внутри экосистемы (через бота/инвайт)
Плюсы:
Гарантия, что каждый адрес прошёл процедуру онбординга (активация инвайта).
Исключение «чужих» адресов, которые не прошли верификацию через invite.
Можно строить доверие и аналитику только на «своих» адресах.
Минусы:
Пользователь не может использовать свой старый кошелёк (например, Metamask), если он не был создан через бота.
Меньшая гибкость для опытных пользователей.
Вариант 2: Разрешать подключать любой адрес (в том числе созданный вне экосистемы)
Плюсы:
Максимальная гибкость для пользователя (можно использовать любой свой кошелёк).
Удобно для опытных пользователей, которые хотят использовать свой основной адрес.
Минусы:
Нет гарантии, что адрес не был скомпрометирован или не используется для мультиаккаунтинга.
Сложнее контролировать уникальность и «чистоту» профилей.
Возможны атаки: кто-то может массово подключать адреса, чтобы получить бонусы/инвайты.
3. Что важно для вашей экосистемы?
Главная ценность:
— Честность, прозрачность, защита от мультиаккаунтинга, доверие между участниками.
Главный риск:
— Если разрешить любые адреса, злоумышленник может подключать много адресов, не проходя invite-онбординг, и «захламлять» экосистему.
4. Рекомендация
Лучший вариант для Amanita:
Разрешать подключать только те адреса, которые прошли процедуру активации инвайта через одного из ботов.
Это может быть как адрес, созданный прямо в боте (через встроенный wallet), так и любой внешний адрес, но только после прохождения invite-онбординга.
После активации инвайта этот адрес становится «профилем» пользователя и может использоваться во всех сервисах.
Если пользователь хочет сменить адрес — он должен пройти процедуру онбординга для нового адреса.
Технически:
В контракте InviteNFT/боте хранить mapping: адрес → статус (активирован/нет).
При попытке подключить адрес — проверять, активирован ли он через invite.
Не разрешать использовать адреса, которые не прошли invite-онбординг.
5. Аргументы в пользу ограничения
Безопасность:
— Только адреса, прошедшие invite, могут участвовать в экосистеме.
Прозрачность:
— Вся история on-chain, нет «левых» адресов.
Масштабируемость:
— Любой продавец может быть уверен, что работает только с «чистыми» участниками.
Анонимность:
— Нет личных данных, только адрес и история on-chain.
6. Возможные компромиссы
Можно разрешить подключать внешний адрес, но только после прохождения invite-онбординга (например, через подпись сообщения или подтверждение владения адресом).
Можно добавить функцию «привязать новый адрес» к существующему профилю, но только после invite.
Вывод
Не стоит разрешать подключать любые адреса без invite-онбординга.
Каждый адрес должен пройти процедуру активации инвайта через одного из ботов.
Это обеспечит честность, прозрачность и безопасность всей экосистемы Amanita.

# Архитектура проверки и UX для подключения/активации адреса

### 1. Проверка адреса при подключении
- При попытке подключить адрес (через бота или dApp) система проверяет, прошёл ли этот адрес процедуру invite-онбординга.
- Проверка реализуется через контракт InviteNFT: адрес должен быть владельцем активированного инвайта (или иметь статус usedInviteByUser[address] != 0).
- Если адрес не прошёл invite-онбординг — подключение отклоняется, пользователю предлагается пройти процедуру активации инвайта.

### 2. Процедура активации адреса (онбординг)
1. Ввод инвайт-кода
Новый пользователь в боте/интерфейсе вводит inviteCode.
Бот (или DApp) проверяет inviteCode на валидность через контракт (view-функция).
2. Создание адреса
Если inviteCode валиден, бот генерирует новый адрес (wallet) прямо в коде (или через встроенный генератор).
Приватный ключ хранится на устройстве пользователя или (если пользователь согласен) в зашифрованном виде в боте (например, с паролем).
3. Активация инвайта
Бот отправляет транзакцию в контракт: активирует inviteCode для нового адреса.
В этот момент:
Инвайт помечается как использованный.
Новый адрес становится активным участником экосистемы (отмечается в мапе usedInviteByUser).
На этот адрес сразу batch-минтятся 12 новых инвайтов для передачи друзьям.
4. Дальнейшее использование
Пользователь получает свой адрес и приватный ключ (или seed-фразу).
Этот адрес теперь — его профиль в экосистеме Amanita.
Он может использовать этот адрес во всех ботах/сервисах, передавать инвайты друзьям, получать токены и т.д.
Почему это правильно:
Гарантия чистоты:
Только адреса, прошедшие invite-онбординг, становятся частью экосистемы.
Безопасность:
Нет возможности подключить «чужой» или скомпрометированный адрес.
UX:
Пользователь получает всё необходимое (адрес, инвайты) в одном процессе.
Масштабируемость:
Любой новый продавец или сервис может работать с этой системой без риска мультиаккаунтинга.
Важно!
Адрес создаётся только после успешной проверки inviteCode.
Активация инвайта и batch mint новых инвайтов происходят в одной транзакции.
Адрес сразу становится активным и получает свои инвайты для раздачи.
Вся история фиксируется в контракте (on-chain).

### 3. UX сценарии
- **Если адрес уже активирован:**
  - Показываем приветствие, даём доступ ко всем функциям.
- **Если адрес не активирован:**
  - Показываем экран онбординга, просим ввести inviteCode или получить его у участника.
  - После успешной активации — сразу выдаём инвайты для раздачи друзьям.
- **Если пользователь хочет сменить адрес:**
  - Новый адрес должен пройти invite-онбординг отдельно.

### 4. Безопасность и прозрачность
- Только адреса, прошедшие invite-онбординг, могут участвовать в экосистеме.
- Нет личных данных, только адрес и история on-chain.
- Любой продавец или сервис может проверить статус адреса через контракт InviteNFT.

### 5. Масштабируемость и децентрализация
- Любой продавец может интегрировать свой бот, не нарушая общую систему пользователей.
- Пользователь может использовать свой адрес во всех сервисах Amanita после единой активации.
- Вся логика проверки статуса адреса — on-chain, без централизованных баз данных.

# Оплата газа для минта инвайтов

Контракт InviteNFT — общий для всей экосистемы.
Каждый продавец (или оператор бота) оплачивает газ только за своих пользователей, которые проходят онбординг через его бота.
Это позволяет строить децентрализованную сеть продавцов, где каждый отвечает за свои расходы, но все работают с единой системой пользователей.
Как это реализовать правильно
1. Общий контракт InviteNFT
Один контракт InviteNFT для всей экосистемы.
Все инвайты, статусы, история — on-chain и доступны любому продавцу/боту.
2. Сервисный кошелёк у каждого продавца
Каждый продавец/бот держит свой сервисный кошелёк с балансом для оплаты газа.
Этот кошелёк используется только для отправки транзакций активации и batch mint инвайтов для своих пользователей.
3. Логика оплаты газа
Когда пользователь проходит онбординг через конкретного бота, именно этот бот (через свой backend/relayer) отправляет транзакцию в InviteNFT и платит газ.
В транзакции явно указывается адрес пользователя, которому минтятся инвайты.
Вся история (кто активировал, кто минтил) фиксируется в событиях контракта.
4. Контроль и аудит
В контракте можно хранить (или эмитить в событиях) адрес минтера (inviteMinter) для каждого инвайта.
Это позволяет в любой момент отследить, какой продавец/бот оплатил выпуск инвайта для конкретного пользователя.
Можно реализовать аналитику, лимиты, бонусы для продавцов.
5. Безопасность
Продавец не может оплачивать газ за чужих пользователей (только за тех, кто прошёл онбординг через его бота).
Если нужно, можно добавить в контракте whitelist/role для сервисных кошельков продавцов (например, только адреса с ролью MINTER_ROLE могут минтить инвайты).
Архитектурная схема
Пользователь → проходит онбординг в боте продавца → вводит inviteCode.
Бот → проверяет inviteCode → генерирует адрес → отправляет транзакцию в InviteNFT через свой сервисный кошелёк.
InviteNFT → минтит инвайты, отмечает inviteCode как использованный, сохраняет адрес минтера.
Пользователь → получает свой адрес и инвайты, становится участником экосистемы.
Вся история — on-chain, любой продавец/бот может проверить статус любого адреса.
Резюме
Контракт InviteNFT — общий.
Каждый продавец платит газ только за своих пользователей через свой сервисный кошелёк.
Вся история минтинга и активации — on-chain, прозрачна для всей экосистемы.
Можно реализовать аналитику, лимиты, бонусы для продавцов.

# Как работает привязка к адресу продавца для оплаты газа при минтинге инвайтов
1. Сервисный кошелёк продавца
У каждого продавца (бота) есть свой приватный ключ/адрес (например, 0xSellerBot1...), на котором лежит баланс для оплаты газа.
Этот адрес не хранится в контракте InviteNFT, а используется на backend-уровне продавца.
2. Процесс активации инвайта
Пользователь проходит онбординг через конкретного бота.
Бот (backend) формирует и подписывает транзакцию на контракт InviteNFT с помощью своего сервисного кошелька.
Именно этот сервисный кошелёк платит газ за транзакцию (минтинг инвайтов для пользователя).
3. On-chain связь
В контракте InviteNFT в событии (например, BatchInvitesMinted) всегда будет видно, с какого адреса была отправлена транзакция (это и есть адрес продавца).
Можно добавить в контракте поле/маппинг inviteMinter[tokenId] = msg.sender; чтобы явно фиксировать, кто минтил инвайт.
4. Контроль и аудит
Любой может посмотреть в блокчейне, какой продавец (адрес) оплатил выпуск инвайта для пользователя.
Можно реализовать аналитику, лимиты, бонусы для продавцов на основе этого поля.
Пример: как это выглядит на практике
Пользователь → проходит онбординг в боте продавца.
Бот (backend) → вызывает функцию activateAndMintInvites в InviteNFT, используя свой сервисный кошелёк.
Контракт InviteNFT:
Минтит инвайты на адрес пользователя.
В маппинге inviteMinter[tokenId] = msg.sender; сохраняет адрес продавца.
В событии BatchInvitesMinted видно, кто минтил.
Баланс для газа списывается с сервисного кошелька продавца.
Важные детали
Контракт InviteNFT не хранит баланс продавца — он просто фиксирует, кто вызвал функцию (msg.sender).
Привязка к продавцу — это всегда адрес, с которого отправлена транзакция.
Безопасность — только продавец контролирует свой сервисный кошелёк и может оплачивать газ за своих пользователей.
Резюме
Привязка к продавцу для оплаты газа — это просто использование его сервисного кошелька для отправки транзакций в InviteNFT.
Вся история минтинга и активации — on-chain, по адресу msg.sender.
Можно добавить явное поле inviteMinter для каждого инвайта, если нужно.

# Логика тестирования инвайтов
Тестовый сценарий онбординга в экосистеме AMANITA
Инициализация продавца
Выбираем первый адрес из локального блокчейна
Назначаем его как аккаунт продавца (бот)
Этот адрес будет оплачивать газ за операции пользователей
Создание начальных инвайтов
Продавец создает 8 инвайтов
Каждый инвайт получает уникальный код
Проверяем, что все инвайты успешно созданы и доступны
Онбординг первого пользователя
Генерируем новый Ethereum-адрес для первого пользователя
Пользователь активирует один из инвайтов продавца
В результате:
Адрес пользователя получает статус "активирован"
Пользователь получает 12 новых инвайтов для приглашений
Все транзакции оплачиваются с баланса продавца
Онбординг второго пользователя
Генерируем новый Ethereum-адрес для второго пользователя
Второй пользователь активирует один из инвайтов первого пользователя
Проверяем:
Успешную активацию адреса
Получение 12 новых инвайтов
Корректность всех статусов и балансов
Верификация событий контракта
Проверяем события InviteActivated (должно быть 2 события)
Проверяем события BatchInvitesMinted (должно быть 3 события)
Верифицируем статусы использованных инвайтов
Проверяем корректность всех маппингов в контракте
Ключевые проверки:
Корректность создания и активации инвайтов
Правильность распределения новых инвайтов
Точность событий и их параметров
Корректность статусов активации
Правильность работы механизма оплаты газа
Этот сценарий тестирует полный цикл онбординга в экосистеме, включая:
Создание инвайтов
Активацию адресов
Распределение новых инвайтов
Механизм оплаты газа
Систему событий контракта

# Анализ деталей контракта


Схема состояний инвайта:
a) Создан:
Инвайт только что заминтирован
Имеет уникальный inviteCode и tokenId
Имеет minter (адрес создателя)
Имеет createdAt (время создания)
Имеет expiry (срок действия, 0 для бессрочных)
isInviteUsed = false
usedInviteByUser[address] = 0
b) Активирован:
Инвайт выбран для активации
Происходит в рамках транзакции activateAndMintInvites
Генерируются новые инвайты для активатора
Еще не помечен как использованный
c) Использован:
isInviteUsed = true
usedInviteByUser[user] = tokenId
Добавлен в историю передач
Не может быть активирован повторно
d) Истек:
block.timestamp > expiry
Не может быть активирован
Сохраняет историю использования
Схема переходов между состояниями:
a) Создан → Активирован:
Проверки:
Инвайт существует
Не истек срок
Не использован ранее
Пользователь не активирован
У продавца достаточно газа
b) Активирован → Использован:
Проверки:
Транзакция успешна
Новые инвайты заминтированы
Статусы обновлены
События испускаются
c) Создан → Истек:
Автоматический переход
Проверки:
block.timestamp > expiry
Инвайт не использован
Матрица проверок безопасности:
a) mintInvites:
Вызывающий: только продавец
Проверки:
Уникальность кодов
Валидность срока
Лимиты на количество
Возможные атаки:
Front-running при создании
DoS через большое количество инвайтов
b) activateAndMintInvites:
Вызывающий: продавец (оплата газа)
Проверки:
Валидность инвайта
Статус пользователя
Уникальность новых кодов
Возможные атаки:
Reentrancy при минтинге
Front-running активации
c) validateInviteCode:
Вызывающий: любой
Проверки:
Существование инвайта
Срок действия
Статус использования
Возможные атаки:
DoS через частые проверки
Схема газовой оптимизации:
a) Частые операции:
Проверка валидности инвайта
Проверка статуса пользователя
Получение списка инвайтов
Активация инвайта
b) Оптимизация хранения:
Использовать uint256 вместо string для inviteCode
Хранить только необходимые данные в маппингах
Использовать пакетную обработку для batch-операций
Оптимизировать структуру событий
c) Off-chain данные:
История передач (можно хранить в событиях)
Статистика использования
Аналитика по инвайтам
Кэширование часто запрашиваемых данных
Дополнительные рекомендации:
a) Безопасность:
Добавить паузу для критических операций
Реализовать механизм отмены транзакций
Добавить лимиты на количество операций
Реализовать механизм обновления контракта
b) Газ:
Использовать unchecked блоки где безопасно
Оптимизировать циклы
Минимизировать чтение из storage
Использовать пакетные операции
c) UX:
Добавить view-методы для удобных проверок
Реализовать batch-операции для массовых действий
Добавить события для всех важных действий
Реализовать механизм отмены/возврата

# Порядок реализации методов контракта InviteNFT

## 1. Базовые view-методы
- Получение базовой информации:
  - `getTokenIdByInviteCode(string memory inviteCode) public view returns (uint256)`
  - `getInviteCodeByTokenId(uint256 tokenId) public view returns (string memory)`
  - `isInviteTokenUsed(uint256 tokenId) public view returns (bool)`
  - `isUserActivated(address user) public view returns (bool)`
  - `getInviteExpiry(uint256 tokenId) public view returns (uint256)`
  - `getInviteCreatedAt(uint256 tokenId) public view returns (uint256)`
  - `getInviteMinter(uint256 tokenId) public view returns (address)`
  - `getInviteFirstOwner(uint256 tokenId) public view returns (address)`

## 2. Методы валидации
- Проверки перед основными операциями:
  - `validateInviteCode(string memory inviteCode, address user) public view returns (bool, string memory)`
  - `batchValidateInviteCodes(string[] memory inviteCodes, address user) public view returns (bool[] memory, string[] memory)`

## 3. Методы создания инвайтов
- Начальная точка для работы с инвайтами:
  - `mintInvites(string[] memory inviteCodes, uint256 expiry) external`

## 4. Методы активации
- Основная бизнес-логика:
  - `activateAndMintInvites(string memory inviteCode, address user, string[] memory newInviteCodes, uint256 expiry) external`

## 5. Методы для работы с историей
- Аналитика и аудит:
  - `getInviteTransferHistory(uint256 tokenId) public view returns (address[] memory)`
  - `getUserInvites(address user) public view returns (uint256[] memory)`
  - `getAllActivatedUsers() public view returns (address[] memory)`

## 6. Вспомогательные методы
- Оптимизация и утилиты:
  - `_mintInvite(string memory inviteCode, address to, uint256 expiry) internal`
  - `_validateInviteCode(string memory inviteCode, address user) internal view returns (bool, string memory)`
  - `_updateInviteStatus(uint256 tokenId, address user) internal`

## Преимущества такого порядка реализации:
1. Постепенное усложнение логики
2. Возможность тестировать каждый этап
3. Наращивание функциональности
4. Оптимизация кода на каждом этапе
5. Упрощение отладки

## Примечания по реализации:
- Каждая группа методов опирается на предыдущую
- Тестирование проводится после каждой группы
- Оптимизация выполняется на каждом этапе
- Документация обновляется параллельно с кодом

# Построение графа роста экосистемы
Благодаря истории инвайтов и их передачи вы сможете строить граф адресов, отслеживать рост экосистемы и анализировать реферальные/пригласительные цепочки.
Как это работает:
История инвайтов (inviteTransferHistory):
Для каждого инвайта (NFT) в контракте хранится массив адресов, которые когда-либо владели этим инвайтом.
Когда пользователь активирует инвайт, его адрес добавляется в историю этого инвайта.
Когда инвайт передаётся (например, через off-chain передачу inviteCode и последующую активацию), новый владелец также фиксируется в истории.
Генерация новых инвайтов:
Когда пользователь активирует инвайт, ему минтятся новые инвайты (NFT) с уникальными inviteCode.
Эти новые инвайты он может раздать другим пользователям (например, друзьям).
Рост графа:
Каждый новый пользователь, который активирует инвайт, становится новой вершиной в графе.
Связь между пользователями строится по цепочке: кто чей инвайт активировал.
Можно строить дерево/граф: кто пригласил кого, сколько «поколений» и т.д.
Аналитика и аудит:
Можно анализировать, кто был самым активным распространителем инвайтов.
Можно выявлять подозрительные схемы (например, мультиаккаунтинг).
Можно строить реферальные программы, бонусы, аналитику роста.
Всё on-chain:
Вся история прозрачна, доступна для анализа любым участником или внешним сервисом.
Нет зависимости от централизованных баз данных — только блокчейн.
Пример визуализации:
Адрес A активировал инвайт продавца → получил 12 новых инвайтов.
Адрес B активировал один из инвайтов A → получил свои 12 инвайтов.
Адрес C активировал инвайт B и т.д.
В inviteTransferHistory и событиях контракта можно проследить всю цепочку: продавец → A → B → C...
Вывод:
Да, архитектура позволяет строить граф роста, реферальные деревья и проводить глубокую аналитику экосистемы — всё это реализуется на основе истории инвайтов и их передачи!