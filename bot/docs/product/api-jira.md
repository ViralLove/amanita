# Roadmap: Двусторонняя синхронизация каталогов WooCommerce ↔ Amanita Blockchain

## Epic: E-commerce ↔ Blockchain Catalog Sync
**Epic ID:** EPIC-002  
**Epic Description:** Полная двусторонняя синхронизация каталогов между WooCommerce и блокчейн экосистемой AMANITA с разделением e-commerce логики и специфики натуральной медицины

---

## Обзор MVP задачи

### Цель MVP
Создать систему, позволяющую:
1. **Загружать каталог скриптом** сразу в блокчейн (уже есть через `/upload`)
2. **Выгружать каталог из WooCommerce** через API в автоматически создаваемый каталог продавца
3. **Разделить e-commerce логику** от специфики Amanita (натуральная медицина)
4. **Обеспечить двустороннюю синхронизацию** между магазином и блокчейном

### Архитектурные принципы
- **Разделение ответственности**: E-commerce логика отделена от специфики Amanita
- **Универсальность**: API работает с любыми e-commerce системами
- **Специфика Amanita**: Описания продуктов содержат специфику натуральной медицины
- **Автоматизация**: Автоматическое создание каталогов продавцов

---

## User Story: WooCommerce → Blockchain Sync

### US-003: Как владелец WooCommerce магазина, я хочу автоматически синхронизировать мой каталог с блокчейном Amanita, чтобы мои товары стали доступны в децентрализованной экосистеме

**Story ID:** US-003  
**Priority:** Critical (MVP)  
**Story Points:** 13  
**Sprint:** Sprint 4  
**Assignee:** Full Stack Team  
**QA:** QA Team  

### Описание
Владелец WooCommerce магазина должен иметь возможность:
- Автоматически синхронизировать весь каталог товаров с блокчейном
- Получать автоматически созданный каталог продавца в блокчейне
- Видеть статус синхронизации каждого товара
- Обновлять товары в реальном времени
- Разделять e-commerce данные от специфики Amanita

### Критерии приемки (Acceptance Criteria)

#### AC-003.1: Массовая синхронизация каталога
- **Given** владелец магазина имеет каталог товаров в WooCommerce
- **When** владелец запускает массовую синхронизацию через API
- **Then** система создает каталог продавца в блокчейне
- **And** все товары синхронизируются с сохранением e-commerce структуры
- **And** специфика Amanita добавляется автоматически к описаниям

#### AC-003.2: Автоматическое создание каталога продавца
- **Given** продавец впервые синхронизирует товары
- **When** система обрабатывает запрос на синхронизацию
- **Then** автоматически создается каталог продавца в блокчейне
- **And** продавцу присваивается уникальный seller_address
- **And** каталог связывается с адресом продавца

#### AC-003.3: Разделение e-commerce и Amanita логики
- **Given** товар содержит стандартные e-commerce данные
- **When** система обрабатывает товар для блокчейна
- **Then** e-commerce данные сохраняются в стандартном формате
- **And** специфика Amanita (вид, форма, свойства) добавляется отдельно
- **And** описания обогащаются информацией о натуральной медицине

#### AC-003.4: Инкрементальная синхронизация
- **Given** каталог уже синхронизирован с блокчейном
- **When** продавец добавляет новые товары или обновляет существующие
- **Then** система синхронизирует только измененные товары
- **And** обновляет каталог продавца в блокчейне
- **And** сохраняет историю изменений

#### AC-003.5: Статус синхронизации
- **Given** товар отправлен на синхронизацию
- **When** система обрабатывает синхронизацию
- **Then** возвращается детальный статус операции
- **And** предоставляется blockchain_id и tx_hash
- **And** логируется вся информация о синхронизации

---

## User Story: Blockchain → WooCommerce Sync

### US-004: Как владелец WooCommerce магазина, я хочу получать каталоги из блокчейна Amanita (включая свои собственные), чтобы расширить мой ассортимент товарами других продавцов и синхронизировать свои товары, загруженные через JSON скрипты

**Story ID:** US-004  
**Priority:** High (MVP)  
**Story Points:** 10  
**Sprint:** Sprint 5  
**Assignee:** Backend Team  
**QA:** QA Team  

### Описание
Владелец WooCommerce магазина должен иметь возможность:
- Получать каталоги из блокчейна (свои и других продавцов)
- Импортировать товары в свой магазин с четкой идентификацией источника
- Фильтровать товары по категориям, продавцам и типу владения
- Обновлять импортированные товары
- Управлять связями между локальными и блокчейн товарами
- Синхронизировать свои товары, загруженные через JSON скрипты

### Критерии приемки (Acceptance Criteria)

#### AC-004.1: Получение каталогов из блокчейна с идентификацией продавцов
- **Given** в блокчейне есть каталоги различных продавцов
- **When** владелец запрашивает доступные каталоги
- **Then** система возвращает список каталогов с метаданными
- **And** четко идентифицирует seller_address каждого продавца
- **And** различает собственные каталоги от каталогов других продавцов
- **And** предоставляет информацию о продавцах и количестве товаров
- **And** позволяет фильтровать по категориям, регионам и типу владения

#### AC-004.2: Импорт товаров с четкой идентификацией источника
- **Given** владелец выбрал каталог для импорта
- **When** система импортирует товары
- **Then** товары создаются в WooCommerce с блокчейн данными
- **And** сохраняется связь с оригинальным блокчейн товаром
- **And** четко идентифицируется seller_address источника товара
- **And** e-commerce данные адаптируются под WooCommerce
- **And** товары помечаются как "собственные" или "импортированные"

#### AC-004.3: Синхронизация собственных товаров из блокчейна
- **Given** владелец загрузил товары в блокчейн через JSON скрипты
- **When** владелец запрашивает синхронизацию своих товаров
- **Then** система находит все товары с его seller_address
- **And** создает или обновляет соответствующие товары в WooCommerce
- **And** сохраняет связь с блокчейн версией товара
- **And** помечает товары как "собственные" с полным контролем

#### AC-004.4: Управление товарами с разными уровнями контроля
- **Given** в магазине есть товары разных типов (собственные, импортированные)
- **When** владелец управляет товарами
- **Then** собственные товары можно полностью редактировать
- **And** импортированные товары имеют ограниченное редактирование
- **And** система четко показывает источник каждого товара
- **And** сохраняется история изменений и источник данных

#### AC-004.5: Обновление импортированных товаров с уведомлениями
- **Given** импортированный товар обновился в блокчейне
- **When** система проверяет обновления
- **Then** товар автоматически обновляется в WooCommerce
- **And** сохраняется история изменений
- **And** уведомляется владелец об обновлениях
- **And** показывается информация об источнике обновления (seller_address)

#### AC-004.6: Фильтрация и поиск по продавцам
- **Given** в магазине есть товары от разных продавцов
- **When** владелец ищет или фильтрует товары
- **Then** можно фильтровать по seller_address
- **And** можно искать по имени продавца
- **And** можно группировать товары по продавцам
- **And** четко отображается источник каждого товара

---

## Технические субтаски (MVP для запуска первых магазинов)

### TASK-003.1: Создание API эндпоинтов для массовой синхронизации
**Task ID:** TASK-003.1  
**Story:** US-003  
**Priority:** Critical (MVP)  
**Estimated Hours:** 6  
**Dependencies:** None  

**Описание:**  
Создать API эндпоинты для массовой синхронизации каталогов WooCommerce с блокчейном. Реализовать эндпоинты для создания каталога продавца и массовой загрузки товаров.

**Технические инструкции:**
- Создать эндпоинт `POST /catalogs/create` для создания каталога продавца
- Создать эндпоинт `POST /catalogs/{seller_address}/sync` для массовой синхронизации
- Реализовать валидацию входных данных через Pydantic модели
- Добавить обработку ошибок и логирование
- Интегрировать с существующей системой аутентификации HMAC

**Модели данных:**
```python
class CatalogCreateRequest(BaseModel):
    seller_name: str
    description: Optional[str]
    categories: List[str]
    region: Optional[str]

class CatalogSyncRequest(BaseModel):
    products: List[ProductSyncData]
    sync_mode: str = "full"  # full, incremental
    preserve_existing: bool = True

class ProductSyncData(BaseModel):
    wc_id: int
    name: str
    description: str
    price: str
    currency: str
    categories: List[str]
    images: List[str]
    attributes: Dict[str, Any]
    # Amanita специфика будет добавлена автоматически
```

### TASK-003.2: Реализация автоматического создания каталога продавца
**Task ID:** TASK-003.2  
**Story:** US-003  
**Priority:** Critical (MVP)  
**Estimated Hours:** 8  
**Dependencies:** TASK-003.1  

**Описание:**  
Реализовать логику автоматического создания каталога продавца в блокчейне. Интегрировать с существующими смарт-контрактами и обеспечить уникальность адресов продавцов.

**Технические инструкции:**
- Создать метод `create_seller_catalog` в `ProductRegistryService`
- Интегрировать с смарт-контрактом `ProductRegistry`
- Реализовать генерацию уникального seller_address
- Добавить валидацию существования каталога
- Обеспечить атомарность операции создания
- Добавить детальное логирование процесса

**Интеграция с блокчейном:**
```python
def create_seller_catalog(self, seller_data: dict) -> dict:
    # 1. Проверка существования каталога
    # 2. Генерация seller_address если не существует
    # 3. Создание каталога в смарт-контракте
    # 4. Сохранение метаданных в IPFS
    # 5. Возврат результата с адресом и CID
```

### TASK-003.3: Разделение e-commerce и Amanita логики
**Task ID:** TASK-003.3  
**Story:** US-003  
**Priority:** Critical (MVP)  
**Estimated Hours:** 10  
**Dependencies:** TASK-003.2  

**Описание:**  
Реализовать систему разделения e-commerce данных от специфики Amanita. Создать адаптеры для преобразования данных и обогащения описаний информацией о натуральной медицине.

**Технические инструкции:**
- Создать класс `EcommerceDataAdapter` для обработки e-commerce данных
- Создать класс `AmanitaDataEnricher` для добавления специфики
- Реализовать маппинг категорий WooCommerce → Amanita
- Добавить автоматическое определение вида и формы продукта
- Создать систему шаблонов описаний для натуральной медицины
- Реализовать валидацию специфики Amanita

**Структура адаптеров:**
```python
class EcommerceDataAdapter:
    def adapt_product(self, wc_product: dict) -> dict:
        # Преобразование WooCommerce данных в универсальный формат
        pass
    
    def extract_categories(self, wc_categories: List) -> List[str]:
        # Маппинг категорий WooCommerce → Amanita
        pass

class AmanitaDataEnricher:
    def enrich_product(self, product: dict) -> dict:
        # Добавление специфики Amanita
        # - Определение вида (amanita_muscaria, etc.)
        # - Определение формы (powder, tincture, etc.)
        # - Обогащение описания
        pass
    
    def generate_organic_description(self, product: dict) -> str:
        # Генерация описания с учетом натуральной медицины
        pass
```

### TASK-003.4: Интеграция с существующим пайплайном каталога
**Task ID:** TASK-003.4  
**Story:** US-003  
**Priority:** Critical (MVP)  
**Estimated Hours:** 6  
**Dependencies:** TASK-003.3  

**Описание:**  
Интегрировать новую функциональность с существующим пайплайном каталога (`catalog_pipeline.py`). Обеспечить совместимость и переиспользование существующего кода.

**Технические инструкции:**
- Расширить `CatalogPipeline` для поддержки WooCommerce данных
- Создать метод `sync_woocommerce_catalog` в пайплайне
- Интегрировать с существующими утилитами загрузки изображений и описаний
- Обеспечить совместимость с существующим форматом данных
- Добавить поддержку инкрементальной синхронизации
- Реализовать кэширование для оптимизации производительности

**Интеграция:**
```python
class CatalogPipeline:
    def sync_woocommerce_catalog(self, seller_address: str, products: List[dict]) -> bool:
        # 1. Адаптация e-commerce данных
        # 2. Обогащение спецификой Amanita
        # 3. Загрузка изображений в IPFS
        # 4. Создание описаний
        # 5. Загрузка в блокчейн
        # 6. Обновление каталога продавца
        pass
```

### TASK-003.5: Создание API эндпоинтов для получения каталогов с идентификацией продавцов
**Task ID:** TASK-003.5  
**Story:** US-004  
**Priority:** High (MVP)  
**Estimated Hours:** 8  
**Dependencies:** TASK-003.4  

**Описание:**  
Создать API эндпоинты для получения каталогов из блокчейна с четкой идентификацией продавцов и поддержкой синхронизации собственных товаров. Реализовать фильтрацию и поиск по каталогам.

**Технические инструкции:**
- Создать эндпоинт `GET /catalogs` для получения списка каталогов с идентификацией продавцов
- Создать эндпоинт `GET /catalogs/{seller_address}` для получения конкретного каталога
- Создать эндпоинт `GET /catalogs/my` для получения собственных каталогов
- Создать эндпоинт `POST /catalogs/{seller_address}/import` для импорта товаров
- Создать эндпоинт `POST /catalogs/my/sync` для синхронизации собственных товаров
- Реализовать фильтрацию по категориям, регионам, продавцам и типу владения
- Добавить пагинацию для больших каталогов
- Интегрировать с существующей системой кэширования

**Модели данных:**
```python
class CatalogListResponse(BaseModel):
    catalogs: List[CatalogInfo]
    total_count: int
    page: int
    page_size: int
    my_catalogs_count: int
    other_catalogs_count: int

class CatalogInfo(BaseModel):
    seller_address: str
    seller_name: str
    product_count: int
    categories: List[str]
    region: Optional[str]
    last_updated: datetime
    is_own_catalog: bool
    ownership_level: str  # "owner", "imported", "shared"

class CatalogImportRequest(BaseModel):
    product_ids: List[str]
    import_mode: str = "create"  # create, update, merge
    target_categories: Optional[List[str]]
    preserve_source_info: bool = True

class MyCatalogSyncRequest(BaseModel):
    sync_mode: str = "full"  # full, incremental
    update_existing: bool = True
    create_missing: bool = True
```

### TASK-003.6: Реализация импорта товаров в WooCommerce с идентификацией источника
**Task ID:** TASK-003.6  
**Story:** US-004  
**Priority:** High (MVP)  
**Estimated Hours:** 10  
**Dependencies:** TASK-003.5  

**Описание:**  
Реализовать логику импорта товаров из блокчейна в WooCommerce с четкой идентификацией источника и поддержкой синхронизации собственных товаров. Создать адаптеры для преобразования блокчейн данных в формат WooCommerce.

**Технические инструкции:**
- Создать класс `WooCommerceImporter` для импорта товаров
- Создать класс `OwnCatalogSynchronizer` для синхронизации собственных товаров
- Реализовать маппинг блокчейн данных → WooCommerce с сохранением seller_address
- Добавить поддержку различных режимов импорта (создание, обновление, слияние)
- Реализовать сохранение связей между локальными и блокчейн товарами
- Добавить обработку изображений и метаданных
- Обеспечить валидацию данных перед импортом
- Реализовать систему меток для различения собственных и импортированных товаров

**Структура импортера:**
```python
class WooCommerceImporter:
    def import_products(self, seller_address: str, product_ids: List[str], is_own_catalog: bool = False) -> List[dict]:
        # 1. Получение товаров из блокчейна
        # 2. Преобразование в формат WooCommerce
        # 3. Создание/обновление товаров с меткой источника
        # 4. Сохранение связей и seller_address
        # 5. Возврат результатов
        pass
    
    def map_blockchain_to_woocommerce(self, blockchain_product: dict, seller_address: str) -> dict:
        # Маппинг полей блокчейн → WooCommerce с сохранением seller_address
        pass
    
    def mark_product_source(self, product_id: int, seller_address: str, is_own: bool):
        # Сохранение метки источника товара
        pass

class OwnCatalogSynchronizer:
    def sync_own_products(self, seller_address: str) -> List[dict]:
        # 1. Поиск всех товаров с seller_address в блокчейне
        # 2. Синхронизация с WooCommerce
        # 3. Пометка как собственные товары
        # 4. Возврат результатов
        pass
    
    def find_own_products_in_blockchain(self, seller_address: str) -> List[dict]:
        # Поиск собственных товаров в блокчейне
        pass
```

### TASK-003.7: Создание системы управления товарами с разными уровнями контроля
**Task ID:** TASK-003.7  
**Story:** US-004  
**Priority:** High (MVP)  
**Estimated Hours:** 8  
**Dependencies:** TASK-003.6  

**Описание:**  
Создать систему управления товарами с четким разделением собственных и импортированных товаров, разными уровнями контроля и идентификацией источника.

**Технические инструкции:**
- Создать модель `ProductOwnership` для отслеживания владения товарами
- Реализовать систему меток для различения типов товаров (собственные/импортированные)
- Создать API для управления правами доступа к товарам
- Реализовать фильтрацию и поиск по seller_address
- Добавить систему уведомлений об изменениях в импортированных товарах
- Создать интерфейс для просмотра источника товаров

**Модели данных:**
```python
class ProductOwnership(BaseModel):
    product_id: int
    seller_address: str
    ownership_type: str  # "own", "imported", "shared"
    blockchain_id: str
    import_date: datetime
    last_sync: datetime
    can_edit: bool
    can_delete: bool
    source_catalog: str

class ProductSourceInfo(BaseModel):
    seller_address: str
    seller_name: str
    catalog_name: str
    import_date: datetime
    last_update: datetime
    update_source: str

class ProductFilterRequest(BaseModel):
    seller_address: Optional[str]
    ownership_type: Optional[str]
    categories: Optional[List[str]]
    search_query: Optional[str]
    page: int = 1
    page_size: int = 20
```

### TASK-003.8: Создание системы отслеживания синхронизации
**Task ID:** TASK-003.8  
**Story:** US-003, US-004  
**Priority:** Medium (MVP)  
**Estimated Hours:** 6  
**Dependencies:** TASK-003.7  

**Описание:**  
Создать систему отслеживания статуса синхронизации товаров. Реализовать API для получения статуса и истории синхронизации.

**Технические инструкции:**
- Создать модель `SyncStatus` для отслеживания состояния
- Реализовать эндпоинт `GET /sync/status/{sync_id}` для получения статуса
- Создать эндпоинт `GET /sync/history/{seller_address}` для истории
- Добавить поддержку уведомлений об изменениях статуса
- Реализовать кэширование статусов для производительности
- Добавить детальное логирование всех операций

**Модели данных:**
```python
class SyncStatus(BaseModel):
    sync_id: str
    seller_address: str
    status: str  # pending, processing, completed, failed
    progress: int  # 0-100
    total_products: int
    processed_products: int
    errors: List[str]
    started_at: datetime
    completed_at: Optional[datetime]
    sync_type: str  # "import", "own_sync", "update"

class SyncHistory(BaseModel):
    sync_records: List[SyncStatus]
    total_count: int
```

### TASK-003.9: Создание unit-тестов для MVP функциональности
**Task ID:** TASK-003.9  
**Story:** US-003, US-004  
**Priority:** Critical (MVP)  
**Estimated Hours:** 10  
**Dependencies:** TASK-003.8  

**Описание:**  
Создать unit-тесты для всей MVP функциональности синхронизации каталогов, включая идентификацию продавцов и управление товарами с разными уровнями контроля.

**Технические инструкции:**
- Создать тестовый файл `test_catalog_sync.py`
- Реализовать тесты для создания каталогов продавцов
- Добавить тесты для массовой синхронизации
- Создать тесты для адаптеров e-commerce данных
- Реализовать тесты для импорта товаров с идентификацией источника
- Добавить тесты для синхронизации собственных товаров
- Создать тесты для системы управления товарами с разными уровнями контроля
- Добавить тесты для системы отслеживания статуса
- Обеспечить покрытие кода минимум 85%

### TASK-003.10: Обновление API документации
**Task ID:** TASK-003.10  
**Story:** US-003, US-004  
**Priority:** Critical (MVP)  
**Estimated Hours:** 4  
**Dependencies:** TASK-003.9  

**Описание:**  
Обновить API документацию для включения новых эндпоинтов синхронизации каталогов с идентификацией продавцов. Добавить примеры использования и интеграции.

**Технические инструкции:**
- Обновить `bot/docs/api.md` с новыми эндпоинтами
- Добавить раздел "Синхронизация каталогов" с подробным описанием
- Создать примеры JSON-запросов и ответов
- Добавить примеры интеграции с WooCommerce
- Создать руководство по миграции существующих каталогов
- Добавить troubleshooting guide
- Добавить документацию по идентификации продавцов и управлению товарами

---

## Отложенные задачи (для следующих спринтов)

### TASK-003.11: Реализация инкрементальной синхронизации
**Task ID:** TASK-003.11  
**Story:** US-003  
**Priority:** Medium  
**Estimated Hours:** 8  
**Dependencies:** TASK-003.8  

**Описание:**  
Реализовать систему инкрементальной синхронизации для оптимизации производительности и снижения нагрузки на блокчейн.

### TASK-003.12: Создание системы уведомлений
**Task ID:** TASK-003.12  
**Story:** US-003, US-004  
**Priority:** Low  
**Estimated Hours:** 6  
**Dependencies:** TASK-003.8  

**Описание:**  
Реализовать систему уведомлений для информирования пользователей о статусе синхронизации и обновлениях каталогов.

### TASK-003.13: Оптимизация производительности
**Task ID:** TASK-003.13  
**Story:** US-003, US-004  
**Priority:** Medium  
**Estimated Hours:** 8  
**Dependencies:** TASK-003.9  

**Описание:**  
Оптимизировать производительность системы синхронизации каталогов через кэширование, батчинг и асинхронную обработку.

---

## Интеграция с WooCommerce плагином

### Расширение существующего плагина

**Новые эндпоинты плагина:**
```php
// Массовая синхронизация каталога
add_action('rest_api_init', function () {
    register_rest_route('amanita/v1', '/catalog/sync', array(
        'methods' => 'POST',
        'callback' => 'amanita_sync_catalog',
        'permission_callback' => 'amanita_check_permissions'
    ));
});

// Получение статуса синхронизации
register_rest_route('amanita/v1', '/catalog/status', array(
    'methods' => 'GET',
    'callback' => 'amanita_get_sync_status',
    'permission_callback' => 'amanita_check_permissions'
));
```

**Новые метабоксы:**
- Каталог продавца: отображение blockchain_id и статуса
- Массовая синхронизация: кнопка для синхронизации всего каталога
- История синхронизации: лог всех операций

### Интеграция с Action Scheduler

```php
// Фоновая синхронизация каталога
add_action('amanita_sync_catalog_async', 'amanita_process_catalog_sync');

function amanita_process_catalog_sync($catalog_data) {
    // 1. Подготовка данных каталога
    // 2. Вызов Python API
    // 3. Обновление статуса
    // 4. Уведомление пользователя
}

// Синхронизация собственных товаров из блокчейна
add_action('amanita_sync_own_products_async', 'amanita_process_own_products_sync');

function amanita_process_own_products_sync($seller_address) {
    // 1. Получение собственных товаров из блокчейна
    // 2. Синхронизация с WooCommerce
    // 3. Пометка как собственные товары
    // 4. Уведомление пользователя
}

// Обновление импортированных товаров
add_action('amanita_update_imported_products_async', 'amanita_process_imported_products_update');

function amanita_process_imported_products_update($product_ids) {
    // 1. Проверка обновлений в блокчейне
    // 2. Обновление товаров в WooCommerce
    // 3. Сохранение истории изменений
    // 4. Уведомление об обновлениях
}
```

### Новые метабоксы и интерфейсы

**Метабокс "Источник товара":**
```php
class ProductSourceMetaBox {
    public function display_source_info($post) {
        $seller_address = get_post_meta($post->ID, '_amanita_seller_address', true);
        $ownership_type = get_post_meta($post->ID, '_amanita_ownership_type', true);
        $blockchain_id = get_post_meta($post->ID, '_amanita_blockchain_id', true);
        
        // Отображение информации об источнике товара
        echo "<div class='amanita-source-info'>";
        echo "<h4>Источник товара</h4>";
        echo "<p><strong>Продавец:</strong> " . esc_html($seller_address) . "</p>";
        echo "<p><strong>Тип владения:</strong> " . esc_html($ownership_type) . "</p>";
        echo "<p><strong>Blockchain ID:</strong> " . esc_html($blockchain_id) . "</p>";
        echo "</div>";
    }
}
```

**Интерфейс управления каталогами:**
```php
class CatalogManagementInterface {
    public function display_catalog_list() {
        // Отображение списка каталогов с фильтрацией
        // Разделение на собственные и импортированные
        // Возможность синхронизации и импорта
    }
    
    public function display_product_filter() {
        // Фильтрация товаров по seller_address
        // Поиск по имени продавца
        // Группировка по продавцам
    }
}
```

---

## Метрики успеха

### MVP метрики (для запуска первых магазинов)
- [ ] Поддержка массовой синхронизации каталогов WooCommerce → Blockchain
- [ ] Автоматическое создание каталогов продавцов
- [ ] Разделение e-commerce и Amanita логики
- [ ] Базовый импорт товаров из блокчейна в WooCommerce
- [ ] Система отслеживания статуса синхронизации

### Технические метрики MVP
- [ ] Покрытие кода unit-тестами ≥ 85%
- [ ] Время синхронизации каталога < 30 секунд
- [ ] 0 критических багов в MVP функционале
- [ ] API документация обновлена

### Бизнес-метрики MVP
- [ ] MVP готов для запуска первых магазинов-нод
- [ ] Поддержка базовой двусторонней синхронизации
- [ ] Разделение ответственности между e-commerce и Amanita
- [ ] Готовность к масштабированию

---

## Заключение

Данный Roadmap обеспечивает создание полноценной системы двусторонней синхронизации каталогов между WooCommerce и блокчейном Amanita. MVP фокус направлен на решение критических задач для запуска первых магазинов, с четким разделением e-commerce логики от специфики натуральной медицины.

Ключевые преимущества реализации:
- **Универсальность**: API работает с любыми e-commerce системами
- **Специализация**: Автоматическое обогащение спецификой Amanita
- **Автоматизация**: Минимальное участие пользователя в процессе
- **Масштабируемость**: Готовность к росту количества магазинов 